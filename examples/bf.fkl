(import ../btk)
(load macro.fkl)

(define code nil)

(if (le (length (argv)) 1)
  (setq code "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.")
  (setq code
        (let ((fp (open (nth 1 (argv)) "rb")))
          (if (eq fp EOF)
            (begin
              (princ "Faild to open file" stderr)
              (exit 1)))
          (define c (read fp))
          (close fp)
          (str c))))

(defmacro (ADDMP)
  `(begin
     (setq mp (add mp 1))
     (if (ge mp (length m))
       (setq m (appd m #b00)))))

(defmacro (SUBMP)
  `(begin
     (if (le mp 0)
         (setq m (appd #b00 mp))
         (setq mp (sub mp 1)))
     ))

(defmacro (ADDM)
  `(let ((c (chr (nth mp m))))
     (setf (nth mp m) (byt (chr (add 1 (int c)))))))

(defmacro (SUBM)
  `(let ((c (chr (nth mp m))))
     (setf (nth mp m) (byt (chr (sub (int c) 1))))))

(defmacro (JUMPIFFALSE $cp)
  `(let ((c (int (nth mp m))))
     (if (eq c 0)
       (let loop ((ch (nth ~cp code)))
         (if (not (eq ch #\]))
           (loop (nth (setq ~cp (add ~cp 1)) code)))))))

(defmacro (JUMPBACK $cp)
  `(let loop ((ch (nth ~cp code)))
     (if (not (eq ch #\[))
       (loop (nth (setq ~cp (sub ~cp 1)) code))
       (setq ~cp (sub ~cp 1)))))

(define m #b00)

(let iter ((cp 0)
           (mp 0))
  (case (nth cp code)
    ((#\>) (ADDMP))
    ((#\<) (SUBMP))
    ((#\+) (ADDM))
    ((#\-) (SUBM))
    ((#\.) (princ (chr (nth mp m)) stdout))
    ((#\,) (setf (nth mp m) (byt (readb 1 stdin))))
    ((#\[) (JUMPIFFALSE cp))
    ((#\]) (JUMPBACK cp)))
  (if (lt cp (length code))
    (iter (add cp 1) mp)))
