(defmacro "'[a]" (cons (quote quote) (cons a nil)))
(defmacro
  (let $d,$b)
  ((lambda ()
     (define map
       (lambda (f l)
         (define map-iter
           (lambda (f c p)
             (cond ((null c) (append p nil))
                   (1 (map-iter f (cdr c) (append p (cons (f (car c)) nil)))))))
         (map-iter f l nil)))
     (define list (lambda ls ls))
     (define args nil)
     (define vals nil)
     (cond ((issym d)
            (setq
              args
              (map (lambda (sd) (nth 0 sd)) (car b)))
            (setq
              vals
              (map (lambda (sd) (nth 1 sd)) (car b)))
            (list 'let
                  '()
                  (list 'define d (cons 'lambda (cons args (cdr b))))
                  (cons d vals)))
           (1
            (setq args
                  (map (lambda (sd) (nth 0 sd)) d))
            (setq vals
                  (map (lambda (sd) (nth 1 sd)) d))
            (cons (cons 'lambda (cons args b)) vals)
            )))))

(let ((a 8)
      (b 9)
      (c 10)
      (d 11))
 (princ a 1)
 (princ b 1)
 (princ c 1)
 (princ d 1))
(princ #\\n stdout)
(let iter ((a 2))
  (princ a stdout)
  (cond ((eq a 0) 0)
        (1 (iter (sub a 1)))))
(let () (princ "end" stdout))
(princ #\\n stdout)
(define i (let ((a 1)) (lambda (x) (add x a))))
(princ (i 2) stdout)
