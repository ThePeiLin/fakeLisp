(import ../btk)
(defmacro "'(a)" (cons (quote quote) (cons a nil)))
(defmacro (define ($name,$args),$body)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'define name (cons 'lambda (cons args body))))))

(defmacro
  (let $d,$b)
  ((lambda ()
     (define map
       (lambda (f l)
         (define map-iter
           (lambda (f c p)
             (cond ((null c) (appd p nil))
                   (1 (map-iter f (cdr c) (appd p (cons (f (car c)) nil)))))))
         (map-iter f l nil)))
     (define list (lambda ls ls))
     (define args nil)
     (define vals nil)
     (cond ((eq (typeof d) 'sym)
            (setq
              args
              (map (lambda (sd) (nth 0 sd)) (car b)))
            (setq
              vals
              (map (lambda (sd) (nth 1 sd)) (car b)))
            (list 'let
                  '()
                  (list 'define d (cons 'lambda (cons args (cdr b))))
                  (cons d vals)))
           (1
            (setq args
                  (map (lambda (sd) (nth 0 sd)) d))
            (setq vals
                  (map (lambda (sd) (nth 1 sd)) d))
            (cons (cons 'lambda (cons args b)) vals))))))

(defmacro (if $condition $exp1,$exp2)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'cond (list condition exp1) (cons 1 exp2)))))

(define (newTerm)
 (princ "\033[?1049h" stdout))
(define (print,ls)
  (let printList ((tls ls))
    (cond ((null (cdr tls)) (princ (car tls) stdout))
          (1 (princ (car tls) stdout) (printList (cdr tls))))))
(define (delTerm)
  (print "\033[?" "1049l"))
(define (moveLeft) (print "\033[1D"))
(define (moveRight) (print "\033[1C"))
(define (moveUp) (print "\033[1A"))
(define (moveDown) (print "\033[1B"))
(define (printFaQ) (princ "FaQ" stdout))

(newTerm)
(let main ((ch (getch)))
 (cond ((eq ch #\h) (moveLeft))
       ((eq ch #\k) (moveUp))
       ((eq ch #\j) (moveDown))
       ((eq ch #\l) (moveRight))
       ((eq ch #\d) (princ #\\0x20 stdout))
       ((eq ch #\\0x20) (printFaQ)))
 (if (not (eq ch #\\4)) (main (getch))))
(delTerm)
