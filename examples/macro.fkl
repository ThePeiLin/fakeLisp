(defmacro "'(a)" (cons (quote quote) (cons a nil)))
(defmacro "`(a)" (cons (quote qsquote) (cons a nil)))
(defmacro "~(a)" (cons (quote unquote) (cons a nil)))
(defmacro "~@(a)" (cons (quote unqtesp) (cons a nil)))
(defmacro "[(,a)]" a)
(defmacro "#d<(m)" `(dll (quote ~m)))
(defmacro "#d>(m):(f)" `(dlsym ~m (quote ~f)))

(defmacro
  (let $d,$b)
  (begin
    (define map
      (lambda (f l)
        (define map-iter
          (lambda (f c p)
            (cond ((null c) (appd p nil))
                  (1 (map-iter f (cdr c) (appd p (cons (f (car c)) nil)))))))
        (map-iter f l nil)))
    (define args nil)
    (define vals nil)
    (cond ((eq (type d) 'sym)
           (setq
             args
             (map (lambda (sd) (nth 0 sd)) (car b)))
           (setq
             vals
             (map (lambda (sd) (nth 1 sd)) (car b)))
           `(let () (define ~d (lambda ~args ~@(cdr b))) ~(cons d vals))
           )
          (1
           (setq args
                 (map (lambda (sd) (nth 0 sd)) d))
           (setq vals
                 (map (lambda (sd) (nth 1 sd)) d))
           `((lambda ~args ~@b) ~@vals)
           ))))

(defmacro
  (let* $d,$b)
  (cond ((or (not (eq (type d) 'pair))
             (le (length d) 1))
         `(let ~d ~@b))
        (1
         `(let (~(car d))
            (let* ~(cdr d) ~@b)))))
(defmacro
  (letrec $d,$b)
  (begin
    (define map
      (lambda (f l)
        (define map-iter
          (lambda (f c p)
            (cond ((null c) (appd p nil))
                  (1 (map-iter f (cdr c) (appd p (cons (f (car c)) nil)))))))
        (map-iter f l nil)))
    (define dfs (map (lambda (sd) `(define ~(car sd) ~@(cdr sd))) d))
    `(let () ~@dfs ~@b)))

(defmacro
  (letcc $t,$b)
  `(clcc (lambda (~t) ~@b)))

(defmacro (if $condition $exp1,$exp2)
  `(cond (~condition ~exp1) ~(cons 1 exp2)))

(defmacro (case $v,$b)
  (begin
    (define map
      (lambda (f l)
        (define map-iter
          (lambda (f c p)
            (cond ((null c) (appd p nil))
                  (1 (map-iter f (cdr c) (appd p (cons (f (car c)) nil)))))))
        (map-iter f l nil)))
    (define body (let ((tb (map (lambda (x) (cdr x)) b))
                       (cs (map (lambda (x)
                                  (if (eq (type x) 'pair)
                                    (cons 'or
                                          (map (lambda (x) `(equal ~v ~x)) x))
                                    x))
                                (map (lambda (x) (nth 0 x)) b))))
                   (map (lambda (x)
                          (define r (cons x (car tb)))
                          (setq tb (cdr tb))
                          r)
                        cs)
                   ))
    `(cond,~body)))

(defmacro (define  ($name,$args),$body)
  `(define ~name (lambda ~args ~@body)))
