(import ../btk)
(defmacro "'[a]" (cons (quote quote) (cons a nil)))
(defmacro
  (let $d,$b)
  ((lambda ()
     (define map
       (lambda (f l)
         (define map-iter
           (lambda (f c p)
             (cond ((null c) (append p nil))
                   (1 (map-iter f (cdr c) (append p (cons (f (car c)) nil)))))))
         (map-iter f l nil)))
     (define list (lambda ls ls))
     (define args nil)
     (define vals nil)
     (cond ((issym d)
            (setq
              args
              (map (lambda (sd) (nth 0 sd)) (car b)))
            (setq
              vals
              (map (lambda (sd) (nth 1 sd)) (car b)))
            (list 'let
                  '()
                  (list 'define d (cons 'lambda (cons args (cdr b))))
                  (cons d vals)))
           (1
            (setq args
                  (map (lambda (sd) (nth 0 sd)) d))
            (setq vals
                  (map (lambda (sd) (nth 1 sd)) d))
            (cons (cons 'lambda (cons args b)) vals))))))

(defmacro (if $condition $exp1,$exp2)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'cond (list condition exp1) (cons 1 exp2)))))

(defmacro (define ($name,$args),$body)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'define name (cons 'lambda (cons args body))))))

(defmacro (ARRY $X $Y)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'add X (list 'mul Y 'rrow)))))

(defmacro (INC $SYM)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'setq SYM (list '1+ SYM)))))
(defmacro (DEC $SYM)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'setq SYM (list '1- SYM)))))
(defmacro (NEG $VALUE)
  ((lambda ()
     (define list (lambda ls ls))
     (list 'sub 0 VALUE))))
(define eq equal)
(define (neq a b) (not (eq a b)))
(define (1+ a) (add a 1))
(define (1- a) (sub a 1))
(define (resl objlist)
  (if (null objlist)
    objlist
    (let loop-tmplist ((tmplist objlist) (tmp nil))
      (if (null (cdr tmplist))
        (cons (car tmplist) tmp)
        (loop-tmplist (cdr tmplist)
                      (cons (car tmplist) tmp))))))
(define (print,ls)
  (let printList ((tls ls))
    (cond ((null (cdr tls)) (princ (car tls) stdout))
          (1 (princ (car tls) stdout) (printList (cdr tls))))))
(define (debugPrint file,ls)
  (let printList ((tls ls))
    (cond ((null (cdr tls)) (princ (car tls) file))
          (1 (princ (car tls) file) (printList (cdr tls))))))
(define (newTerm)
  (princ "\033[?1049h" stdout))

(define (delTerm)
  (princ "\033[?1049l" stdout))

(define (createEmptyList size)
  (let loop-count ((count 1) (list '((1,0))))
    (if (ge count size)
      list
      (loop-count (1+ count)
                  (cons '(1,0) list)))))

(define (setl list place value)
  (define (getafter list place count)
    (cond ((le place count) (cdr list))
          (1 (getafter (cdr list)
                       place
                       (1+ count)))))
  (define (getbefore list place count tmp)
    (cond ((le place count) tmp)
          (1 (getbefore (cdr list)
                        place
                        (1+ count)
                        (cons (car list) tmp)))))
  (append (resl (getbefore list place 0 nil))
          (cons value (getafter list place 0))))

(define (createMap line row bombnum)
  (define rline (add line 2))
  (define rrow (add row 2))
  (define gMap (createEmptyList (mul rline rrow)))
  (let loop-yc ((yc 0))
    (cond ((le yc (1+ line))
           (let loop-xc ((xc 0))
             (cond ((le xc (1+ row))
                    (if (or (eq yc 0)
                            (eq yc (1+ line))
                            (eq xc 0)
                            (eq xc (1+ row)))
                      (setq gMap (setl gMap (ARRY xc yc) (cons 4 10))))
                    (loop-xc (1+ xc)))))
           (loop-yc (1+ yc)))))
  (let loop-i ((i 0))
    (define yr (1+ (rand line)))
    (define xr (1+ (rand row)))
    (define place (ARRY xr yr))
    (define front (car (nth place gMap)))
    (define back (cdr (nth place gMap)))
    (cond ((lt i bombnum)
           (cond ((eq back 0)
                  (setq gMap (setl gMap
                                  place
                                  (cons front
                                        9)))))
           (loop-i (add i
                        (if (eq back 0) 1 0))))))
  (define (getAroundBombNum gMap x y)
    (define i 0)
    (if (eq (cdr (nth (ARRY (1- x) (1- y)) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY x (1- y)) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1+ x) (1- y)) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1- x) y) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1+ x) y) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1- x) (1+ y)) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY x (1+ y)) gMap)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1+ x) (1+ y)) gMap)) 9) (INC i))
    i)
  (let loop-yc ((yc 1))
    (cond ((le yc line)
           (let loop-xc ((xc 1))
             (define place (ARRY xc yc))
             (define front (car (nth place gMap)))
             (define back (cdr (nth place gMap)))
             (cond ((le xc row)
                    (if (neq back 9)
                      (setq gMap
                            (setl gMap
                                  place
                                  (cons front
                                        (getAroundBombNum gMap xc yc)))))
                    (loop-xc (1+ xc)))))
           (loop-yc (1+ yc)))))
  gMap)

(define (canOpenBlock gMap row line x y tier)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define (canOpen gMap row line x y xt yt)
    (and (and (ge (sub y yt) 1)
              (le (sub y yt) line)
              (ge (sub x xt) 1)
              (le (sub x xt) row))
         (or (eq (nth (ARRY (1- (sub x xt)) (sub y yt)) gMap) '(1,0))
             (eq (nth (ARRY (sub x xt) (1+ (sub y yt))) gMap) '(1,0))
             (eq (nth (ARRY (sub x xt) (1- (sub y yt))) gMap) '(1,0))
             (eq (nth (ARRY (1+ (sub x xt)) (sub y yt)) gMap) '(1,0)))
         (and (eq (car (nth (ARRY (sub x xt) (sub y yt)) gMap)) 1)
              (neq (cdr (nth (ARRY (sub x xt) (sub y yt)) gMap)) 9))))
  (define isCan nil)
  (let loop-yt ((yt tier))
    (cond ((and (gt yt (1- (NEG tier))) (not isCan))
           (let loop-xt ((xt tier))
             (cond ((and (gt xt (1- (NEG tier))) (not isCan))
                    (if (canOpen gMap row line x y xt yt)
                      (setq isCan 1)
                      (loop-xt (sub xt (if (or (eq yt tier)
                                               (eq yt (NEG tier)))
                                         1
                                         (mul tier 2))))))))
           (loop-yt (1- yt)))))
  isCan)

(define (canOpenThisBlock gMap row line x y xt yt)
  (define rrow (add row 2))
  (define rline (add line 2))
  (and (and (ge (sub y yt) 1)
            (le (sub y yt) line)
            (ge (sub x xt) 1)
            (le (sub x xt) row))
       (or (and (neq (car (nth (ARRY (1- (sub x xt)) (sub y yt)) gMap)) 4)
                (eq (cdr (nth (ARRY (1- (sub x xt)) (sub y yt)) gMap)) 0))
           (and (neq (car (nth (ARRY (1+ (sub x xt)) (sub y yt)) gMap)) 4)
                (eq (cdr (nth (ARRY (1+ (sub x xt)) (sub y yt)) gMap)) 0))
           (and (neq (car (nth (ARRY (sub x xt) (1- (sub y yt))) gMap)) 4)
                (eq (cdr (nth (ARRY (sub x xt) (1- (sub y yt))) gMap)) 0))
           (and (neq (car (nth (ARRY (sub x xt) (1+ (sub y yt))) gMap)) 4)
                (eq (cdr (nth (ARRY (sub x xt) (1+ (sub y yt))) gMap)) 0)))))

(define (haveUnopenedBlock gMap row line x y tier)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define ishave nil)
  (define (subHaveOpen gMap row line x y xt yt)
    (and (and (ge (sub y yt) 1)
              (le (sub y yt) line)
              (ge (sub x xt) 1)
              (le (sub x xt) row))
         (or (and (neq (car (nth (ARRY (1- (sub x xt)) (sub y yt)) gMap)) 4)
                  (eq (cdr (nth (ARRY (1- (sub x xt)) (sub y yt)) gMap)) 0))
             (and (neq (car (nth (ARRY (1+ (sub x xt)) (sub y yt)) gMap)) 4)
                  (eq (cdr (nth (ARRY (1+ (sub x xt)) (sub y yt)) gMap)) 0))
             (and (neq (car (nth (ARRY (sub x xt) (1- (sub y yt))) gMap)) 4)
                  (eq (cdr (nth (ARRY (sub x xt) (1- (sub y yt))) gMap)) 0))
             (and (neq (car (nth (ARRY (sub x xt) (1+ (sub y yt))) gMap)) 4)
                  (eq (cdr (nth (ARRY (sub x xt) (1+ (sub y yt))) gMap)) 0)))
         (and (eq (car (nth (ARRY (sub x xt) (sub y yt)) gMap)) 1)
              (neq (cdr (nth (ARRY (sub x xt) (sub y yt)) gMap)) 9))))
  (let loop-yt ((yt tier))
    (cond ((and (gt yt (1- (NEG tier))) (not ishave))
           (let loop-xt ((xt tier))
             (cond ((and (gt xt (1- (NEG tier))) (not ishave))
                    (if (subHaveOpen gMap row line x y xt yt)
                      (setq ishave 1)
                      (loop-xt (sub xt (if (or (eq yt tier)
                                               (eq yt (NEG tier)))
                                         1
                                         (mul tier 2))))))))
           (loop-yt (1- yt)))))
  ishave)

(define (printMap gMap row line xl yl bombNum)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define (printBombNum)
    (define yb (1+ (int (div rline 2))))
    (define xb (add rrow 2))
    (print "\033[0m\033[" yb ";" xb "H")
    (princ "\033[K" stdout)
    (print "mines:" bombNum))
  (princ "\033[1;1H" stdout)
  (let loop-yp ((yp 0))
    (cond ((le yp (1+ line))
           (let loop-xp ((xp 0))
             (define light (if (and (eq xp (1- xl))
                                    (eq yp (1- yl)))
                             46
                             0))
             (define place (ARRY xp yp))
             (cond ((le xp (1+ row))
                    (let ((front (car (nth place gMap)))
                          (back (cdr (nth place gMap))))
                      (cond ((eq front 0)
                             (cond ((eq back 0)
                                    (print "\033[0m\033["
                                           light
                                           "m."))
                                   ((lt back 9)
                                    (print "\033[0m\033["
                                           light
                                           "m" back))
                                   (1 (print "\033[0m\033["
                                             light
                                             "m*"))))
                            ((eq front 1)
                             (print "\033[0m\033["
                                    light
                                    "m="))
                            ((eq front 2)
                             (print "\033[0m\033["
                                    light
                                    "m!"))
                            ((eq front 3)
                             (print "\033[0m\033["
                                    light
                                    "m?"))
                            ((eq front 4)
                             (princ "\033[0m\033[44m#"
                                    stdout))))
                    (loop-xp (1+ xp)))))
           (princ "\n" stdout)
           (loop-yp (1+ yp)))))
  (printBombNum))

(define (main gMap line row bombnum)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define xl (int (1+ (div rrow 2))))
  (define yl (int (1+ (div rline 2))))
  (define rbombnum bombnum)
  (define isGameOver nil)
  (define (moveUp) (setq yl (sub yl (if (gt yl 2) 1 0))))
  (define (moveDown) (setq yl (add yl (if (lt yl (1+ line)) 1 0))))
  (define (moveLeft) (setq xl (sub xl (if (gt xl 2) 1 0))))
  (define (moveRight) (setq xl (add xl (if (lt xl (1+ row)) 1 0))))
  (define (setFlag)
    (define place (ARRY (1- xl) (1- yl)))
    (define front (car (nth place gMap)))
    (define back (cdr (nth place gMap)))
    (cond ((eq front 1)
           (DEC bombnum)
           (if (eq back 9) (DEC rbombnum)))
          ((eq front 2)
           (INC bombnum)
           (if (eq back 9) (INC rbombnum))))
    (setq gMap
          (setl gMap
                place
                (cons (if (eq front 3)
                        1
                        (1+ front))
                      back))))
  (define (quit)
    (setq isGameOver 1))
  (define (openBlock)
    (define x (1- xl))
    (define y (1- yl))
    (define place (ARRY x y))
    (define front (car (nth place gMap)))
    (define back (cdr (nth place gMap)))
    (cond ((eq back 9)
           (setq isGameOver 1))
          ((neq back 0)
           (setq gMap
                 (setl gMap
                       place
                       (cons 0 back))))
          (1
           (setq gMap (setl gMap place (cons 0 back)))
           (let loop-tier ((tier 1))
             (cond ((canOpenBlock gMap row line x y tier)
                    (let loop-yt ((yt tier))
                      (cond ((gt yt (1- (NEG tier)))
                             (let loop-xt ((xt tier))
                               (cond ((gt xt (1- (NEG tier)))
                                      (cond ((canOpenThisBlock gMap row line x y xt yt)
                                             (let ((place (ARRY (sub x xt) (sub y yt))))
                                               (define front (car (nth place gMap)))
                                               (define back (cdr (nth place gMap)))
                                               (setq gMap
                                                     (setl gMap
                                                           place
                                                           (cons 0 back))))))
                                      (loop-xt (sub xt (if (or (eq yt tier)
                                                               (eq yt (NEG tier)))
                                                         1
                                                         (mul tier 2)))))))
                             (loop-yt (1- yt)))))
                    (loop-tier (add tier (if (haveUnopenedBlock gMap row line x y tier) 0 1)))))))
          ))
  (define (openAllBlock)
    (define numOfBlock (mul (add line 2) (add row 2)))
    (let loop-i ((i 0))
      (cond ((lt i numOfBlock)
             (let ((back (cdr (nth i gMap)))
                   (front (car (nth i gMap))))
               (if (neq front 4) (setq gMap (setl gMap i (cons 0 back)))))
             (loop-i (1+ i))))))
  (printMap gMap row line xl yl bombnum)
  (let loop-ch ((ch (getch)))
    (cond ((eq ch #\h) (moveLeft))
          ((eq ch #\k) (moveUp))
          ((eq ch #\j) (moveDown))
          ((eq ch #\l) (moveRight))
          ((eq ch #\a) (setFlag))
          ((eq ch #\s) (openBlock))
          ((eq ch #\q) (quit)))
    (printMap gMap row line xl yl bombnum)
    (cond (isGameOver (openAllBlock)
                      (printMap gMap row line xl yl bombnum)
                      (print "\033[" (int (div rline 2)) ";" (add rrow 2) "H" "You fail!")
                      ))
    (cond ((eq 0 rbombnum)
           (print "\033[" (int (div rline 2)) ";" (add rrow 2) "H" "You win!")
           (setq isGameOver 1)))
    (if (and (not isGameOver) (neq ch #\\4)) (loop-ch (getch)))))

(newTerm)
(princ "Input line and row\n" stdout)
(define line (read stdin))
(define row (read stdin))
(princ "Input bomb number\n" stdout)
(define bombNum (read stdin))
(princ "\033[2J" stdout)
(define gMap (createMap line row bombNum))
(main gMap line row bombNum)
(define rline (add line 2))
(define rrow (add row 2))
(print "\033[" (add (int (div rline 2)) 2) ";" (add rrow 2) "H" "Press any key to quit.")
(getch)
(print "\033[2J")
(delTerm)
