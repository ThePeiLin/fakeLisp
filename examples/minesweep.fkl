;;This program havn't been finished yet.
(defmacro (let ATOM#LETNAME ((ATOM#NAME ANY#VALUE) VAREPT#OTHER),PAIR#BODY)
          (cons (list 'define LETNAME (cons 'lambda (cons (cons NAME OTHER#NAME) BODY))) (cons VALUE OTHER#VALUE)))
(defmacro
 (if ANY#COND ANY#EXPRESSION1,ANY#EXPRESSION2)
 (list 'cond (list COND EXPRESSION1) (cons 1 EXPRESSION2)))

(defmacro (define (ATOM#NAME,ANY#ARG),PAIR#EXPRESSION)
          (list 'define NAME (cons 'lambda (cons ARG EXPRESSION))))

(defmacro (ARRY ANY#X ANY#Y)
 (list 'add X (list 'mul Y 'rrow)))

(define (neq a b) (not (eq a b)))
(define (1+ a) (add a 1))
(define (1- a) (sub a 1))
(define (resl objlist)
 (let loop ((tmplist objlist) (tmp nil))
  (if (null (cdr tmplist))
      (cons (car tmplist) tmp)
      (loop (cdr objlist)
            (cons (car tmplist) tmp)))))

(define (newTerm)
 (write "\033[?1049h" stdout))

(define (delTerm)
 (write "\033[?1049l" stdout))

(define (createEmptyList size)
 (let loop ((count 1) (list '()))
  (if (eq size count)
      list
      (loop (1+ count)
            (append list '())))))

(define (setl list place value)
 (define (getafter list place count)
  (cond ((eq place count) (cdr list))
        (1 (getafter
               (cdr list) 
               place 
               (1+ count)))))
 (define (getbefore list place count tmp)
  (cond ((eq place count) (cons (car list) tmp))
        (1 (getbefore (cdr list)
                         place
                         (1+ count)
                         (cons (car list) tmp)))))
 (append (resl (getbefore list place 0 '()))
         (cons value (getafter list place 0))))

(define (getMapFront place map) (car (nth place map)))
(define (getMapBack place map) (cdr (nth place map)))

(define (createMap line row bombnum)
 (define rline (add line 2))
 (define rrow (add row 2))
 (define map (createEmptyList (mul rline rrow)))
 (let loop ((i 0))
  (cond ((lt i (mul rline rrow))
         (setq map (setl map i (cons 1 0)))
         (loop (1+ i)))))
 (let loop ((yc 0))
  (cond ((le yc (add line row))
         (let loop1 ((xc 0))
          (cond ((le xc (1+ row))
                 (if (or (eq yc 0)
                         (eq yc (1+ line))
                         (eq xc 0)
                         (eq xc (1+ row)))
                     (setq map (setl map (ARRY xc yc) (cons 4 9))))
                 (loop1 (1+ xc)))))
         (loop (1+ yc)))))
 (let loop ((i 0))
  (define yr (1+ (rand line)))
  (define xr (1+ (rand row)))
  (define place (ARRY xr yr))
  (cond ((lt i bombnum)
         (setq i (add i 
                      (if (eq (cdr (nth place map)) 0) 1 0)))
         (setq map (setl map 
                         place 
                         (cons (car (nth place map))
                               (if (eq (cdr (nth place map)) 9) 0 9))))
         (loop i))))
 (define (getAroundBombNum map x y)
  (define i 0)
  (if (eq (cdr (nth (ARRY (1- x) (1- y 1)) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY x (1- y)) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY (1+ x) (1- y 1)) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY (1- x 1) y) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY (1+ x) y) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY (1- x 1) (1+ y)) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY x (1+ y)) map)) 9) (setq i (1+ i)))
  (if (eq (cdr (nth (ARRY (1+ x) (1+ y)) map)) 9) (setq i (1+ i)))
  i)
 (let loop ((yc 1))
  (cond ((le yc line)
         (let loop1 ((xc 1))
          (define place (ARRY xc yc))
          (cond ((le xc row)
                 (if (neq (cdr (nth place  map)) 9)
                     (setq map
                           (setl map 
                                 place 
                                 (cons (car (nth place map))
                                       (getAroundBombNum map xc yc)))))
                 (loop1 (1+ xc)))))
         (loop (1+ yc)))))
 map)

(define (main map line row)
 (define rrow (add row 2))
 (define rline (add line 2))
 (define xl (int (1+ (div rrow 2))))
 (define yl (int (1+ (div rline 2))))
 (define (moveUp) (setq yl (sub yl (if (gt yl 2) 1 0))))
 (define (moveDown) (setq yl (add yl (if (lt yl (1+ line)) 1 0))))
 (define (moveLeft) (setq xl (sub xl (if (gt xl 2) 1 0))))
 (define (moveRight) (setq xl (add xl (if (lt xl (1+ row)) 1 0))))
 (define isGameOver nil)
 (let loop (())
  (define ch (getch))
  (cond ((eq ch #\h) (moveLeft))
        ((eq ch #\k) (moveUp))
        ((eq ch #\j) (moveDown))
        ((eq ch #\l) (moveRight))
        ((eq ch #\a) (setFlag))
        ((eq ch #\s) (openBlock))
        ((eq ch #\q) (quit)))
  (if (not isGameOver) (loop))))
