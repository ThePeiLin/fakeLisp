;;This program havn't been finished yet.
(defmacro (let ATOM#LETNAME ((ATOM#NAME ANY#VALUE) VAREPT#OTHER),PAIR#BODY)
          (cons (list 'define LETNAME (cons 'lambda (cons (cons NAME OTHER#NAME) BODY))) (cons VALUE OTHER#VALUE)))
(defmacro (let ((ATOM#NAME ANY#VALUE) VAREPT#OTHER),PAIR#BODY)
          (cons (cons 'lambda (cons (cons NAME OTHER#NAME) BODY)) (cons VALUE OTHER#VALUE)))
(defmacro
  (if ANY#COND ANY#EXPRESSION1,ANY#EXPRESSION2)
  (list 'cond (list COND EXPRESSION1) (cons 1 EXPRESSION2)))

(defmacro (define (ATOM#NAME,ANY#ARG),PAIR#EXPRESSION)
          (list 'define NAME (cons 'lambda (cons ARG EXPRESSION))))

(defmacro (ARRY ANY#X ANY#Y)
  (list 'add X (list 'mul Y 'rrow)))

(defmacro (INC ATOM#SYM)
  (list 'setq SYM (list '1+ SYM)))
(defmacro (DEC ATOM#SYM)
  (list 'setq SYM (list '1- SYM)))
(defmacro (NEG ANY#VALUE)
  (list 'sub 0 VALUE))
(define (neq a b) (not (eq a b)))
(define (1+ a) (add a 1))
(define (1- a) (sub a 1))
(define (resl objlist)
  (if (null objlist) 
      objlist
      (let loop-tmplist ((tmplist objlist) (tmp nil))
        (if (null (cdr tmplist))
            (cons (car tmplist) tmp)
            (loop-tmplist (cdr tmplist)
                          (cons (car tmplist) tmp))))))
(define (print,ls)
  (let printList ((tls ls))
    (cond ((null (cdr tls)) (write (car tls) stdout))
          (1 (write (car tls) stdout) (printList (cdr tls))))))
(define (newTerm)
  (write "\033[?1049h" stdout))

(define (delTerm)
  (write "\033[?1049l" stdout))

(define (createEmptyList size)
  (let loop-count ((count 1) (list '((1,0))))
    (if (ge count size)
        list
        (loop-count (1+ count)
                    (cons '(1,0) list)))))

(define (setl list place value)
  (define (getafter list place count)
    (cond ((le place count) (cdr list))
          (1 (getafter (cdr list) 
                       place 
                       (1+ count)))))
  (define (getbefore list place count tmp)
    (cond ((le place count) tmp)
          (1 (getbefore (cdr list)
                        place
                        (1+ count)
                        (cons (car list) tmp)))))
  (append (resl (getbefore list place 0 nil))
          (cons value (getafter list place 0))))

(define (createMap line row bombnum)
  (define rline (add line 2))
  (define rrow (add row 2))
  (define map (createEmptyList (mul rline rrow)))
  (let loop-yc ((yc 0))
    (cond ((le yc (1+ line))
           (let loop-xc ((xc 0))
             (cond ((le xc (1+ row))
                    (if (or (eq yc 0)
                            (eq yc (1+ line))
                            (eq xc 0)
                            (eq xc (1+ row)))
                        (setq map (setl map (ARRY xc yc) (cons 4 10))))
                    (loop-xc (1+ xc)))))
           (loop-yc (1+ yc)))))
  (let loop-i ((i 0))
    (define yr (1+ (rand line)))
    (define xr (1+ (rand row)))
    (define place (ARRY xr yr))
    (define front (car (nth place map)))
    (define back (cdr (nth place map)))
    (cond ((lt i bombnum)
           (cond ((eq back 0)
           (setq map (setl map 
                           place 
                           (cons front
                                 9)))))
           (loop-i (add i 
                        (if (eq back 0) 1 0))))))
  (define (getAroundBombNum map x y)
    (define i 0)
    (if (eq (cdr (nth (ARRY (1- x) (1- y)) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY x (1- y)) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1+ x) (1- y)) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1- x) y) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1+ x) y) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1- x) (1+ y)) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY x (1+ y)) map)) 9) (INC i))
    (if (eq (cdr (nth (ARRY (1+ x) (1+ y)) map)) 9) (INC i))
    i)
  (let loop-yc ((yc 1))
    (cond ((le yc line)
           (let loop-xc ((xc 1))
             (define place (ARRY xc yc))
             (define front (car (nth place map)))
             (define back (cdr (nth place map)))
             (cond ((le xc row)
                    (if (neq back 9)
                        (setq map
                              (setl map 
                                    place 
                                    (cons front
                                          (getAroundBombNum map xc yc)))))
                    (loop-xc (1+ xc)))))
           (loop-yc (1+ yc)))))
  map)

(define (canOpen map row line x y tier)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define yt tier)
  (define xt tier)
  (if (and (and (ge (sub y yt) 1)
                (le (sub y yt) line)
                (ge (sub x xt) 1)
                (le (sub x xt) row))
           (or (eq (nth (ARRY (1- (sub x xt)) (sub y yt)) map) '(1,0))
               (eq (nth (ARRY (sub x xt) (1+ (sub y yt))) map) '(1,0))
               (eq (nth (ARRY (sub x xt) (1- (sub y yt))) map) '(1,0))
               (eq (nth (ARRY (1+ (sub x xt)) (sub y yt)) map) '(1,0)))
           (and (eq (car (nth (ARRY (sub x xt) (sub y yt)) map)) 1)
                (neq (cdr (nth (ARRY (sub x xt) (sub y yt)) map)) 9)))
      1
      nil))
(define (canOpenBlock map row line x y tier)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define isCan nil)
     (let loop-yt ((yt tier))
       (cond ((and (gt yt (1- (NEG tier))) (not isCan))
              (let loop-xt ((xt tier))
                (cond ((and (gt xt (1- (NEG tier))) (not isCan))
                       (if (canOpen map row line x y tier)
                           (setq isCan 1)
                           (loop-xt (sub xt (if (or (eq yt tier)
                                                    (eq yt (NEG tier)))
                                                1
                                                (mul tier 2)))))))))
             (1 (loop-yt (1- yt)))))
  isCan)

(define (printMap map row line xl yl bombNum)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define (printBombNum)
    (define yb (1+ (int (div rline 2))))
    (define xb (add rrow 2))
    (print "\033[0m\033[" yb ";" xb "H")
    (write "\033[K" stdout)
    (print "mines:" bombNum))
  (write "\033[1;1H" stdout)
  (let loop-yp ((yp 0))
    (cond ((le yp (1+ line))
           (let loop-xp ((xp 0))
             (define light (if (and (eq xp (1- xl))
                                    (eq yp (1- yl)))
                               46
                               0))
             (define place (ARRY xp yp))
             (cond ((le xp (1+ row))
                    (let ((front (car (nth place map)))
                          (back (cdr (nth place map))))
                      (cond ((eq front 0)
                             (if (le back 9)
                                 (print "\033[0m\033["
                                        light
                                        "m" back)
                                 (print "\033[0m\033["
                                        light
                                        "m*")))
                             ((eq front 1)
                              (print "\033[0m\033["
                                     light
                                     "m="))
                             ((eq front 2)
                              (print "\033[0m\033["
                                     light
                                     "m!"))
                             ((eq front 3)
                              (print "\033[0m\033["
                                     light
                                     "m?"))
                             ((eq front 4)
                              (write "\033[0m\033[44m#"
                                     stdout))))
                    (loop-xp (1+ xp)))))
           (write "\n" stdout)
           (loop-yp (1+ yp)))))
  (printBombNum))

(define (main map line row bombnum)
  (define rrow (add row 2))
  (define rline (add line 2))
  (define xl (int (1+ (div rrow 2))))
  (define yl (int (1+ (div rline 2))))
  (define rbombnum bombnum)
  (define isGameOver nil)
  (define (moveUp) (setq yl (sub yl (if (gt yl 2) 1 0))))
  (define (moveDown) (setq yl (add yl (if (lt yl (1+ line)) 1 0))))
  (define (moveLeft) (setq xl (sub xl (if (gt xl 2) 1 0))))
  (define (moveRight) (setq xl (add xl (if (lt xl (1+ row)) 1 0))))
  (define (setFlag)
    (define place (ARRY (1- xl) (1- yl)))
    (define front (car (nth place map)))
    (define back (cdr (nth place map)))
    (cond ((eq front 1)
           (DEC bombnum)
           (if (eq back 9) (DEC rbombnum)))
          ((eq front 2)
           (INC bombnum)
           (if (eq back 9) (INC rbombnum))))
    (setq map
          (setl map
                place
                (cons (if (eq front 3)
                          1
                          (1+ front))
                      back))))
  (define (quit)
    (setq isGameOver 1)
    (delTerm))
  (define (openBlock)
    (define x (1- xl))
    (define y (1- yl))
    (define place (ARRY x y))
    (define front (car (nth place map)))
    (define back (cdr (nth place map)))
    (cond ((eq back 9)
           (setq isGameOver 1))
          (1 ;(neq back 0)
           (setq map
                 (setl map
                       place
                       (cons 0 back))))
         ; (1
         ;  (setq map (setl map place (cons 0 back)))
         ;  (let loop-tier ((tier 1))
         ;      (cond ((canOpenBlock map row line x y tier)
         ;             (let loop-yt ((yt tier))
         ;               (cond ((gt yt (1- (NEG tier)))
         ;                      (let loop-xt ((xt tier))
         ;                        (define place (ARRY (sub x xt) (sub y yt)))
         ;                        (define front (car (nth place map)))
         ;                        (define back (cdr (nth place map)))
         ;                        (cond ((gt xt (1- (NEG xt)))
         ;                               (setq map
         ;                                     (setl map
         ;                                           place
         ;                                           (cons (if (canOpen map row line x y tier) 0 front)
         ;                                                 back)))
         ;                               (loop-xt (sub xt (if (or (eq yt tier)
         ;                                                        (eq yt (NEG tier)))
         ;                                                    1
         ;                                                    (mul tier 2)))))))
         ;                      (loop-yt (1- yt)))))
         ;             (loop-tier (add tier (if (canOpenBlock map row line x y tier) 1 0)))))))
         ))
  (printMap map row line xl yl bombnum)
  (let loop-ch ((ch (getch)))
    (cond ((eq ch #\h) (moveLeft))
          ((eq ch #\k) (moveUp))
          ((eq ch #\j) (moveDown))
          ((eq ch #\l) (moveRight))
          ((eq ch #\a) (setFlag))
          ((eq ch #\s) (openBlock))
          ((eq ch #\q) (quit)))
    (printMap map row line xl yl bombnum)
    (if (neq ch #\\4) (loop-ch (getch)))))
(newTerm)
(write "Input line and row\n" stdout)
(define line (read stdin))
(define row (read stdin))
(write "Input bomb number\n" stdout)
(define bombNum (read stdin))
(define map (createMap line row bombNum))
(write map stderr)
(write #\\n stderr)
(main map line row bombNum)
(delTerm)
