(import (std))

(define btk (dll "btk"))
(define getch (dlsym btk "getch"))
(define rand (dlsym btk "rand"))

(defmacro (ARRY X Y)
  `(+ ~X (* ~Y rrow)))

(defmacro (INC SYM)
  `(setq ~SYM (1+ ~SYM)))
(defmacro (DEC SYM)
  `(setq ~SYM (-1+ ~SYM)))
(defmacro (NEG VALUE)
  `(- 0 ~VALUE))

(define (neq a b) (not (equal a b)))
(define (resl objlist)
  (if (null objlist)
    objlist
    (let loop-tmplist ((tmplist objlist)
                       (tmp nil))
      (if (null (cdr tmplist))
        (cons (car tmplist) tmp)
        (loop-tmplist (cdr tmplist)
                      (cons (car tmplist) tmp))))))
(define (print,ls)
  (let print-list ((tls ls))
    (cond ((null (cdr tls)) (princ (car tls)))
          (1 (princ (car tls)) (print-list (cdr tls))))))

(define (fprint fp,ls)
  (let iter ((tls ls))
    (cond ((null (cdr tls)) (princ (car tls) fp))
          (1 (princ (car tls) fp) (iter (cdr tls))))))

(define (debug-print file,ls)
  (let print-list ((tls ls))
    (cond ((null (cdr tls)) (princ (car tls) file))
          (1 (princ (car tls) file) (print-list (cdr tls))))))
(define (new-term)
  (princ "\033[?1049h"))

(define (del-term)
  (princ "\033[?1049l"))

(define (create-empty-list size)
  (let loop-count ((count 1) (list '((1,0))))
    (if (>= count size)
      list
      (loop-count (1+ count)
                  (cons '(1,0) list)))))

(define (create-map line row bombnum)
  (define rline (+ line 2))
  (define rrow (+ row 2))
  (define g-map (create-empty-list (* rline rrow)))
  (let loop-yc ((yc 0))
    (cond ((<= yc (1+ line))
           (let loop-xc ((xc 0))
             (cond ((<= xc (1+ row))
                    (if (or (equal yc 0)
                            (equal yc (1+ line))
                            (equal xc 0)
                            (equal xc (1+ row)))
                      (setf (nth (ARRY xc yc) g-map) (cons 4 10)))
                    (loop-xc (1+ xc)))))
           (loop-yc (1+ yc)))))
  (let loop-i ((i 0))
    (define yr (1+ (rand line)))
    (define xr (1+ (rand row)))
    (define place (ARRY xr yr))
    (define front (car (nth place g-map)))
    (define back (cdr (nth place g-map)))
    (cond ((< i bombnum)
           (cond ((equal back 0)
                  (setf (nth place g-map)
                        (cons front
                              9))))
           (loop-i (+ i
                      (if (equal back 0) 1 0))))))
  (define (get-around-bomb-num g-map x y)
    (define i 0)
    (if (equal (cdr (nth (ARRY (-1+ x) (-1+ y)) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY x (-1+ y)) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY (1+ x) (-1+ y)) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY (-1+ x) y) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY (1+ x) y) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY (-1+ x) (1+ y)) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY x (1+ y)) g-map)) 9) (INC i))
    (if (equal (cdr (nth (ARRY (1+ x) (1+ y)) g-map)) 9) (INC i))
    i)
  (let loop-yc ((yc 1))
    (cond ((<= yc line)
           (let loop-xc ((xc 1))
             (define place (ARRY xc yc))
             (define front (car (nth place g-map)))
             (define back (cdr (nth place g-map)))
             (cond ((<= xc row)
                    (if (neq back 9)
                      (setf (nth place g-map)
                            (cons front
                                  (get-around-bomb-num g-map xc yc))))
                    (loop-xc (1+ xc)))))
           (loop-yc (1+ yc)))))
  g-map)

(define (can-open-block g-map row line x y tier)
  (define rrow (+ row 2))
  (define rline (+ line 2))
  (define (can-open g-map row line x y xt yt)
    (and (and (>= (- y yt) 1)
              (<= (- y yt) line)
              (>= (- x xt) 1)
              (<= (- x xt) row))
         (or (equal (nth (ARRY (-1+ (- x xt)) (- y yt)) g-map) '(1,0))
             (equal (nth (ARRY (- x xt) (1+ (- y yt))) g-map) '(1,0))
             (equal (nth (ARRY (- x xt) (-1+ (- y yt))) g-map) '(1,0))
             (equal (nth (ARRY (1+ (- x xt)) (- y yt)) g-map) '(1,0)))
         (and (equal (car (nth (ARRY (- x xt) (- y yt)) g-map)) 1)
              (neq (cdr (nth (ARRY (- x xt) (- y yt)) g-map)) 9))))
  (define is-can nil)
  (let loop-yt ((yt tier))
    (cond ((and (> yt (-1+ (NEG tier))) (not is-can))
           (let loop-xt ((xt tier))
             (cond ((and (> xt (-1+ (NEG tier))) (not is-can))
                    (if (can-open g-map row line x y xt yt)
                      (setq is-can 1)
                      (loop-xt (- xt (if (or (equal yt tier)
                                             (equal yt (NEG tier)))
                                       1
                                       (* tier 2))))))))
           (loop-yt (-1+ yt)))))
  is-can)

(define (can-open-this-block g-map row line x y xt yt)
  (define rrow (+ row 2))
  (define rline (+ line 2))
  (and (and (>= (- y yt) 1)
            (<= (- y yt) line)
            (>= (- x xt) 1)
            (<= (- x xt) row))
       (or (and (neq (car (nth (ARRY (-1+ (- x xt)) (- y yt)) g-map)) 4)
                (equal (cdr (nth (ARRY (-1+ (- x xt)) (- y yt)) g-map)) 0))
           (and (neq (car (nth (ARRY (1+ (- x xt)) (- y yt)) g-map)) 4)
                (equal (cdr (nth (ARRY (1+ (- x xt)) (- y yt)) g-map)) 0))
           (and (neq (car (nth (ARRY (- x xt) (-1+ (- y yt))) g-map)) 4)
                (equal (cdr (nth (ARRY (- x xt) (-1+ (- y yt))) g-map)) 0))
           (and (neq (car (nth (ARRY (- x xt) (1+ (- y yt))) g-map)) 4)
                (equal (cdr (nth (ARRY (- x xt) (1+ (- y yt))) g-map)) 0)))))

(define (have-unopened-block g-map row line x y tier)
  (define rrow (+ row 2))
  (define rline (+ line 2))
  (define ishave nil)
  (define (sub-have-open g-map row line x y xt yt)
    (and (and (>= (- y yt) 1)
              (<= (- y yt) line)
              (>= (- x xt) 1)
              (<= (- x xt) row))
         (or (and (neq (car (nth (ARRY (-1+ (- x xt)) (- y yt)) g-map)) 4)
                  (equal (cdr (nth (ARRY (-1+ (- x xt)) (- y yt)) g-map)) 0))
             (and (neq (car (nth (ARRY (1+ (- x xt)) (- y yt)) g-map)) 4)
                  (equal (cdr (nth (ARRY (1+ (- x xt)) (- y yt)) g-map)) 0))
             (and (neq (car (nth (ARRY (- x xt) (-1+ (- y yt))) g-map)) 4)
                  (equal (cdr (nth (ARRY (- x xt) (-1+ (- y yt))) g-map)) 0))
             (and (neq (car (nth (ARRY (- x xt) (1+ (- y yt))) g-map)) 4)
                  (equal (cdr (nth (ARRY (- x xt) (1+ (- y yt))) g-map)) 0)))
         (and (equal (car (nth (ARRY (- x xt) (- y yt)) g-map)) 1)
              (neq (cdr (nth (ARRY (- x xt) (- y yt)) g-map)) 9))))
  (let loop-yt ((yt tier))
    (cond ((and (> yt (-1+ (NEG tier))) (not ishave))
           (let loop-xt ((xt tier))
             (cond ((and (> xt (-1+ (NEG tier))) (not ishave))
                    (if (sub-have-open g-map row line x y xt yt)
                      (setq ishave 1)
                      (loop-xt (- xt (if (or (equal yt tier)
                                             (equal yt (NEG tier)))
                                       1
                                       (* tier 2))))))))
           (loop-yt (-1+ yt)))))
  ishave)

(define (print-map g-map row line xl yl bomb-num)
  (define rrow (+ row 2))
  (define rline (+ line 2))
  (define (print-bomb-num)
    (define yb (1+ (int (/ rline 2))))
    (define xb (+ rrow 2))
    (print "\033[0m\033[" yb ";" xb "H")
    (princ "\033[K")
    (print "mines:" bomb-num))
  (princ "\033[1;1H")
  (let loop-yp ((yp 0))
    (cond ((<= yp (1+ line))
           (let loop-xp ((xp 0))
             (define light (if (and (equal xp (-1+ xl))
                                    (equal yp (-1+ yl)))
                             46
                             0))
             (define place (ARRY xp yp))
             (cond ((<= xp (1+ row))
                    (let ((front (car (nth place g-map)))
                          (back (cdr (nth place g-map))))
                      (case front
                        ((0) (cond ((equal back 0)
                                    (print "\033[0m\033["
                                           light
                                           "m."))
                                   ((< back 9)
                                    (print "\033[0m\033["
                                           light
                                           "m" back))
                                   (1 (print "\033[0m\033["
                                             light
                                             "m*"))))
                        ((1) (print "\033[0m\033["
                                    light
                                    "m="))
                        ((2) (print "\033[0m\033["
                                    light
                                    "m!"))
                        ((3) (print "\033[0m\033["
                                    light
                                    "m?"))
                        ((4) (princ "\033[0m\033[44m#"))))
                    (loop-xp (1+ xp)))))
           (princ "\n")
           (loop-yp (1+ yp)))))
  (print-bomb-num))

(define (main g-map line row bombnum)
  (define rrow (+ row 2))
  (define rline (+ line 2))
  (define xl (int (1+ (/ rrow 2))))
  (define yl (int (1+ (/ rline 2))))
  (define rbombnum bombnum)
  (define is-game-over nil)
  (define (move-up) (setq yl (- yl (if (> yl 2) 1 0))))
  (define (move-down) (setq yl (+ yl (if (< yl (1+ line)) 1 0))))
  (define (move-left) (setq xl (- xl (if (> xl 2) 1 0))))
  (define (move-right) (setq xl (+ xl (if (< xl (1+ row)) 1 0))))
  (define (set-flag)
    (define place (ARRY (-1+ xl) (-1+ yl)))
    (define front (car (nth place g-map)))
    (define back (cdr (nth place g-map)))
    (cond ((equal front 1)
           (DEC bombnum)
           (if (equal back 9) (DEC rbombnum)))
          ((equal front 2)
           (INC bombnum)
           (if (equal back 9) (INC rbombnum))))
    (setf (nth place g-map)
          (cons (if (equal front 3)
                  1
                  (1+ front))
                back)))
  (define (quit)
    (setq is-game-over 1))
  (define (open-block)
    (define x (-1+ xl))
    (define y (-1+ yl))
    (define place (ARRY x y))
    (define front (car (nth place g-map)))
    (define back (cdr (nth place g-map)))
    (cond ((equal back 9)
           (setq is-game-over 1))
          ((neq back 0)
           (setf (nth place g-map)
                 (cons 0 back)))
          (1
           (setf (nth place g-map) (cons 0 back))
           (let loop-tier ((tier 1))
             (cond ((can-open-block g-map row line x y tier)
                    (let loop-yt ((yt tier))
                      (cond ((> yt (-1+ (NEG tier)))
                             (let loop-xt ((xt tier))
                               (cond ((> xt (-1+ (NEG tier)))
                                      (cond ((can-open-this-block g-map row line x y xt yt)
                                             (let ((place (ARRY (- x xt) (- y yt))))
                                               (define front (car (nth place g-map)))
                                               (define back (cdr (nth place g-map)))
                                               (setf (nth place g-map)
                                                     (cons 0 back)))))
                                      (loop-xt (- xt (if (or (equal yt tier)
                                                             (equal yt (NEG tier)))
                                                       1
                                                       (* tier 2)))))))
                             (loop-yt (-1+ yt)))))
                    (loop-tier (+ tier (if (have-unopened-block g-map row line x y tier) 0 1)))))))))
  (define (open-all-block)
    (define num-of-block (* (+ line 2) (+ row 2)))
    (let loop-i ((i 0))
      (cond ((< i num-of-block)
             (let ((back (cdr (nth i g-map)))
                   (front (car (nth i g-map))))
               (if (neq front 4) (setf (nth i g-map) (cons 0 back))))
             (loop-i (1+ i))))))
  (print-map g-map row line xl yl bombnum)
  (let loop-ch ((ch (getch)))
    (case ch
      ((#\h) (move-left))
      ((#\k) (move-up))
      ((#\j) (move-down))
      ((#\l) (move-right))
      ((#\a) (set-flag))
      ((#\s) (open-block))
      ((#\q) (quit)))
    (print-map g-map row line xl yl bombnum)
    (cond (is-game-over (open-all-block)
                      (print-map g-map row line xl yl bombnum)
                      (if (equal ch #\q)
                        (print "\033[" (int (/ rline 2)) ";" (+ rrow 2) "H")
                        (print "\033[" (int (/ rline 2)) ";" (+ rrow 2) "H" "You fail!"))))
    (cond ((equal 0 rbombnum)
           (print "\033[" (int (/ rline 2)) ";" (+ rrow 2) "H" "You win!")
           (setq is-game-over 1)))
    (if (and (not is-game-over) (neq ch #\\4)) (loop-ch (getch)))))

(new-term)
(princ "Input line and row\n")
(define line (read stdin))
(define row (read stdin))
(princ "Input bomb number\n")
(define bomb-num (read stdin))
(princ "\033[2J")
(define g-map (create-map line row bomb-num))
(main g-map line row bomb-num)
(define rline (+ line 2))
(define rrow (+ row 2))
(print "\033[" (+ (int (/ rline 2)) 2) ";" (+ rrow 2) "H" "Press any key to quit.")
(getch)
(print "\033[2J")
(del-term)
