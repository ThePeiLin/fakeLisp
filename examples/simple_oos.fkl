(load macro.fkl)

(defmacro (class $name,$body)
  (begin
    (define data-list nil)
    (define pre-method-list nil)
    (define method-list nil)
    (define construct-method nil)
    (define case-list nil)

    (let loop ((c body))
      (cond (c
              (letcc break
                     (define segmentId (car (car c)))
                     (define segmentData (cdr (car c)))
                     (if (and (not (eq segmentId 'data))
                              (not (eq segmentId 'method)))
                       (break nil))
                     (case segmentId
                       (('data) (setf data-list (appd data-list segmentData)))
                       (('method) (setf pre-method-list (appd pre-method-list segmentData)))))
              (loop (cdr c)))))

    (let loop ((c data-list))
      (cond (c (let ((name (car (car c))))
                 (setf case-list (cons `(((quote ~name)) ~name) case-list)))
               (loop (cdr c)))))

    (let loop ((c pre-method-list))
      (cond (c
              (let ((methodName (car (car c))))
                (cond ((not (eq methodName name))
                       (setf method-list (cons `(~methodName (lambda ~@(cdr (car c)))) method-list))
                       (setf case-list (cons `(((quote ~methodName)) ~methodName) case-list)))
                      (1
                       (setf construct-method (cdr (car c))))))
              (loop (cdr c)))))
    (setf case-list
          (appd case-list
                `((1
                  (princ "Invalid selector \"" stderr)
                  (princ selector stderr)
                  (princ "\"\n" stderr)))))

    (define local-env (appd data-list method-list))
    `(begin
       (define ~name
         (lambda ~(car construct-method)
           (letrec ~local-env
             ~@(cdr construct-method)
             (lambda (selector)
               (case selector
                 ~@case-list))))))))

(define print
  (lambda l
    (define p-iter
      (lambda (c)
        (cond (c (princ (car c) stdout)
                 (p-iter (cdr c))))))
    (p-iter l)))

(class Vec3
       (data
         (X 0.0)
         (Y 0.0)
         (Z 0.0))

       (method
         (Vec3 (x y z)
               (setf X (dbl x))
               (setf Y (dbl y))
               (setf Z (dbl z)))
         (setX (x)
               (setf X (dbl x)))
         (setY (y)
               (setf Y (dbl y)))
         (setZ (z)
               (setf Z (dbl z)))))


(define i (Vec3 1 2 3))

(print " X:" (i 'X)
       " Y:" (i 'Y)
       " Z:" (i 'Z)
       #\\n)

((i 'setX) 9)
((i 'setY) 8)
((i 'setZ) 7)

(print " X:" (i 'X)
       " Y:" (i 'Y)
       " Z:" (i 'Z)
       #\\n)
