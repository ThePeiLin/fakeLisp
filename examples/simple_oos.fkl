(import (.. lib utils))

(defmacro (class name,body)
  (begin
    (define data-list nil)
    (define pre-method-list nil)
    (define method-list nil)
    (define construct-method nil)
    (define case-list nil)

    (let loop ((c body))
      (cond (c
              (letcc break
                     (define segment-id (car (car c)))
                     (define segment-data (cdr (car c)))
                     (if (and (not (eq segment-id 'data))
                              (not (eq segment-id 'method)))
                       (break nil))
                     (case segment-id
                       (('data) (setq data-list (append data-list segment-data)))
                       (('method) (setq pre-method-list (append pre-method-list segment-data)))))
              (loop (cdr c)))))

    (let loop ((c data-list))
      (cond (c (let ((name (car (car c))))
                 (setq case-list (cons `(((quote ~name)) ~name) case-list)))
               (loop (cdr c)))))

    (let loop ((c pre-method-list))
      (cond (c
              (let ((method-name (car (car c))))
                (cond ((not (eq method-name name))
                       (setq method-list (cons `(~method-name (lambda ~@(cdr (car c)))) method-list))
                       (setq case-list (cons `(((quote ~method-name)) ~method-name) case-list)))
                      (1
                       (setq construct-method (cdr (car c))))))
              (loop (cdr c)))))
    (setq case-list
          (append case-list
                `((1
                   (raise (error 'passing-member-symbol 'invalid-selector (append "error:Invalid selector \"" (to-str selector) "\"\n")))))))

    (define local-env (append data-list method-list))
    `(define ~name
       (lambda ~(car construct-method)
         (letrec ~local-env
           ~@(cdr construct-method)
           (define this
             (lambda (selector)
               (case selector
                 ~@case-list))))))))

(define print
  (lambda l
    (define p-iter
      (lambda (c)
        (cond (c (princ (car c))
                 (p-iter (cdr c))))))
    (p-iter l)))

(class Vec3
       (data
         (X 0.0)
         (Y 0.0)
         (Z 0.0))

       (method
         (Vec3 (x y z)
               (setq X (f64 x))
               (setq Y (f64 y))
               (setq Z (f64 z)))
         (set-X (x)
               (setq X (f64 x)))
         (set-Y (y)
               (setq Y (f64 y)))
         (set-Z (z)
               (setq Z (f64 z)))))


(define i (Vec3 1 2 3))

(print " X:" (i 'X)
       " Y:" (i 'Y)
       " Z:" (i 'Z)
       #\\n)

((i 'set-X) 9)
((i 'set-Y) 8)
((i 'set-Z) 7)

(print " X:" (i 'X)
       " Y:" (i 'Y)
       " Z:" (i 'Z)
       #\\n)
