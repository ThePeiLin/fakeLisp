(import (only (.. utils m) static-strcat))

(import (.. bdb))

(define file-prefix "> ")
(define line-prefix "-> ")

(define help-doc
  (static-strcat
    "help: print this help doc or print the help of command\n"
    "exit: exit\n"
    "list: list source code\n"
    "continue: continue the program until end or reach break point\n"
    "break: set break point\n"
    "delete: delete break point\n"
    "next: run the program until next line\n"
    "step: run the program until next line, but step in function\n"
    "restart: restart the debugger\n"
    "return: run the program until function return\n"))

(define help-doc-hash
  (make-hash
    'exit "exit"
    'list "list source code"
    'continue "continue the program until end or reach break point"
    'break "set break point"
    'delete "delete break point"
    'next "run the program until next line, but step in function"
    'step "run the program until next line, but step in function"
    'return "run the program until function return"
    'restart "restart the debugger"
    'help "print this help doc or print the help of command"))

(define (print-cur-line ctx file-prefix line-prefix)
  (define cur-file-line (debug-ctx-get-curline ctx))
  (when cur-file-line
    (println file-prefix
             (vec-ref cur-file-line 0)
             ":"
             (vec-ref cur-file-line 1))
    (print line-prefix (vec-ref cur-file-line 2))))

(define (unknown-cmd-func,_)
  (println "unknown command"))

(define (print-break-point-brief breakpoint)
  (printf "%s %d at %s:%d\n"
          (if (vec-ref breakpoint 5)
            "temp-break"
            "breakpoint")
          (vec-ref breakpoint 0)
          (vec-ref breakpoint 1)
          (vec-ref breakpoint 2)))

(define (print-break-point breakpoint)
  (print-break-point-brief breakpoint)

  (define cond-exp (vec-ref breakpoint 3))
  (if cond-exp
    (printf "\tstop only if %S\n" (unbox cond-exp)))

  (define count (vec-ref breakpoint 4))
  (if (> count 0)
    (printf "\tbreakpoint already hit %d time(s)\n" count)))

(define (debug-continue ctx)
  (define bp (debug-ctx-continue ctx))
  (when bp
    (print "reached ")
    (print-break-point-brief bp))
  (print-cur-line ctx file-prefix line-prefix))

(define (debug-breakpoint ctx,rest)
  (cond
    [rest
      (define breakpoint (apply debug-ctx-set-break ctx rest))
      (if (vector? breakpoint)
        (print-break-point breakpoint)
        (println breakpoint))]
    [1
     (define breakpoints (debug-ctx-list-break ctx))
     (when breakpoints
       (foreach print-break-point breakpoints))]))

(define (debug-temporary-breakpoint ctx,rest)
  (cond
    [rest
      (define breakpoint (apply debug-ctx-set-tbreak ctx rest))
      (if (vector? breakpoint)
        (print-break-point breakpoint)
        (println breakpoint))]
    [1
     (define breakpoints (debug-ctx-list-break ctx))
     (when breakpoints
       (foreach print-break-point breakpoints))]))

(define (debug-del-breakpoint ctx,rest)
  (foreach
    (lambda (num)
      (define bp (debug-ctx-del-break ctx num))
      (if (vector? bp)
        (begin
          (print "deleted ")
          (print-break-point bp))
        (begin
          (if (> num bp)
            (println "breakpoint number "
                     num
                     " out of range")
            (println "breakpoint number "
                     num
                     " already be deleted")))))
    rest))

(define default-list-line-num 11)

(define (print-src-from-to ctx cur 1st last)
  (define not-curline-prefix (make-string (length line-prefix) #\\s))
  (define line-list '())
  (define number-len 0)
  (setq line-list (cons cur line-list))
  (let loop [(n (1+ 1st))]
    (define cur (debug-ctx-list-src ctx n))
    (when (and (< n last) cur)
      (setq line-list (cons cur line-list))
      (loop (1+ n))))

  (setq line-list (reverse! line-list))

  (foreach
    (lambda (x)
      (define cur-len (length (number->string (vec-ref x 0))))
      (if (> cur-len number-len)
        (setq number-len cur-len)))
    line-list)

  (foreach
    (lambda (x)
      (printf "%*s %s%s"
              number-len
              (vec-ref x 0)
              (if (vec-ref x 1)
                line-prefix
                not-curline-prefix)
              (vec-ref x 2)))
    line-list))

(define (debug-list-src ctx,rest)
  (define 1st-line nil)
  (define cur nil)
  (cond
    [(and rest
       (setq 1st-line (car rest))
       (setq cur (debug-ctx-list-src ctx 1st-line)))
     (define last-line (and (cdr rest) (car (cdr rest))))
     (if last-line
       (setq last-line (1+ last-line))
       (setq last-line (+ 1st-line default-list-line-num)))
     (print-src-from-to ctx
                        cur
                        1st-line
                        last-line)]
    [(setq cur (debug-ctx-list-src ctx))
     (setq 1st-line (vec-ref cur 0))
     (define last-line (+ 1st-line default-list-line-num))
     (print-src-from-to ctx
                        cur
                        1st-line
                        last-line)
     (debug-ctx-set-list-src ctx last-line)]
    [1 (println "[EOF]")]))

(define (debug-return ctx)
  (debug-ctx-set-step-out ctx)
  (debug-continue ctx))

(define (debug-step ctx)
  (debug-ctx-set-step-into ctx)
  (debug-continue ctx))

(define (debug-next ctx)
  (debug-ctx-set-step-over ctx)
  (debug-continue ctx))

(define (debug-until ctx,rest)
  (apply debug-ctx-set-until ctx rest)
  (debug-continue ctx))

(define (debug-where ctx)
  (debug-ctx-back-trace ctx line-prefix))

(define (debug-thread ctx,rest)
  (if rest
    (if (debug-ctx-switch-thread ctx (car rest))
      (debug-ctx-print-cur-frame ctx line-prefix))
    (debug-ctx-list-thread ctx line-prefix)))

(define (debug-up ctx,rest)
  (define count (if (and rest (> (car rest) 0)) (car rest) 1))
  (define last-result nil)
  (do [(c 0 (1+ c))]
    [(or (>= c count)
       (not (if (define cur-result (debug-ctx-up ctx))
              (setq last-result cur-result))))])

  (when last-result
    (debug-ctx-print-cur-frame ctx line-prefix)))

(define (debug-down ctx,rest)
  (define count (if (and rest (> (car rest) 0)) (car rest) 1))
  (define last-result nil)
  (do [(c 0 (1+ c))]
    [(or (>= c count)
       (not (if (define cur-result (debug-ctx-down ctx))
              (setq last-result cur-result))))])

  (when last-result
    (debug-ctx-print-cur-frame ctx line-prefix)))

(define debug-cmd-func
  (make-hash
    'exit debug-ctx-exit
    'continue debug-continue
    'break debug-breakpoint
    'tbreak debug-temporary-breakpoint
    'delete debug-del-breakpoint
    'list debug-list-src
    'next debug-next
    'step debug-step
    'return debug-return
    'eval debug-ctx-eval
    'until debug-until
    'where debug-where
    'up debug-up
    'down debug-down
    'thread debug-thread
    'help (lambda (_,rest)
            (if rest
              (if (cdr rest)
                (println "invalid command\n")
                (println (hash-ref help-doc-hash
                                   (car rest)
                                   "do not have such a command")
                         #\\n))
              (println help-doc)))))

(define cmd-abbr-map
  #hash((b,break)
        (c,continue)
        (n,next)
        (s,step)
        (r,return)
        (h,help)))

(define (debug-ctx-run ctx prompt file-prefix line-prefix)
  (print-cur-line ctx file-prefix line-prefix)
  (do []
    [(debug-ctx-end? ctx)]
    (define cmd (debug-ctx-repl ctx prompt))
    (unless (eof? cmd)
      (define cmd-func (hash-ref debug-cmd-func
                                 (car cmd)
                                 unknown-cmd-func))
      (apply cmd-func ctx (cdr cmd)))))

(define (fdb-main)

  (define arg-list (cdr (argv)))

  (if (null arg-list)
    (exit))

  (define file-name (car arg-list))

  (define dbg-ctx (make-debug-ctx file-name arg-list))

  (when (error? dbg-ctx)
    (raise dbg-ctx))

  (define prompt "(fdb) ")
  
  (define cmd-func-table
    (make-hash))

  (debug-ctx-run dbg-ctx prompt file-prefix line-prefix))

(if *main?*
  (fdb-main))
