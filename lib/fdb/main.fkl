(import (.. bdb))

(import (cmd))

(define file-prefix "> ")
(define line-prefix "-> ")

(define (print-cur-line ctx file-prefix line-prefix)
  (define cur-file-line (debug-ctx-get-curline ctx))
  (when cur-file-line
    (println file-prefix
             (vec-ref cur-file-line 0)
             ":"
             (vec-ref cur-file-line 1))
    (print line-prefix (vec-ref cur-file-line 2))))

(define (print-break-point-brief breakpoint)
  (define temp-dis (vec-ref breakpoint 5))
  (printf "%s%s %d at %s:%d\n"
          (if (car temp-dis) "" "disabled ")
          (if (cdr temp-dis)
            "temp-break"
            "breakpoint")
          (vec-ref breakpoint 0)
          (vec-ref breakpoint 1)
          (vec-ref breakpoint 2)))

(define (print-break-point breakpoint)
  (print-break-point-brief breakpoint)

  (define cond-exp (vec-ref breakpoint 3))
  (if cond-exp
    (printf "\tstop only if %S\n" (unbox cond-exp)))

  (define count (vec-ref breakpoint 4))
  (if (> count 0)
    (printf "\tbreakpoint already hit %d time(s)\n" count)))

(define (debug-restart ctx)
  (when (debug-ctx-restart ctx)
    (print-cur-line ctx file-prefix line-prefix)))

(define (debug-continue ctx)
  (cond
    [(debug-ctx-done? ctx)
     (debug-restart ctx)]
    [1
     (define bp (debug-ctx-continue ctx))
     (when bp
       (print "reached ")
       (print-break-point-brief bp))
     (print-cur-line ctx file-prefix line-prefix)]))

(define (debug-breakpoint ctx,rest)
  (cond
    [rest
      (define breakpoint (apply debug-ctx-set-break ctx rest))
      (if (vector? breakpoint)
        (print-break-point breakpoint)
        (println breakpoint))]
    [1
     (define breakpoints (debug-ctx-list-break ctx))
     (when breakpoints
       (foreach print-break-point breakpoints))]))

(define (debug-temporary-breakpoint ctx,rest)
  (cond
    [rest
      (define breakpoint (apply debug-ctx-set-tbreak ctx rest))
      (if (vector? breakpoint)
        (print-break-point breakpoint)
        (println breakpoint))]
    [1
     (define breakpoints (debug-ctx-list-break ctx))
     (when breakpoints
       (foreach print-break-point breakpoints))]))

(define (debug-del-breakpoint ctx,rest)
  (foreach
    (lambda (num)
      (define bp (debug-ctx-del-break ctx num))
      (if (vector? bp)
        (begin
          (print "deleted ")
          (print-break-point-brief bp))
        (begin
          (if (> num bp)
            (println "breakpoint number "
                     num
                     " out of range")
            (println "breakpoint number "
                     num
                     " already be deleted")))))
    rest))

(define (debug-dis-breakpoint ctx,rest)
  (foreach
    (lambda (num)
      (define bp (debug-ctx-dis-break ctx num))
      (if (vector? bp)
        (print-break-point-brief bp)
        (begin
          (if (> num bp)
            (println "breakpoint number "
                     num
                     " out of range")
            (println "breakpoint number "
                     num
                     " already be deleted")))))
    rest))

(define (debug-enable-breakpoint ctx,rest)
  (foreach
    (lambda (num)
      (define bp (debug-ctx-enable-break ctx num))
      (if (vector? bp)
        (begin
          (print "enabled ")
          (print-break-point-brief bp))
        (begin
          (if (> num bp)
            (println "breakpoint number "
                     num
                     " out of range")
            (println "breakpoint number "
                     num
                     " already be deleted")))))
    rest))

(define default-list-line-num 11)

(define (print-src-from-to ctx cur 1st last)
  (define not-curline-prefix (make-string (length line-prefix) #\\s))
  (define line-list '())

  (setq line-list (cons cur line-list))
  (let loop [(n (1+ 1st))]
    (define cur (debug-ctx-list-src ctx n))
    (when (and (< n last) cur)
      (setq line-list (cons cur line-list))
      (loop (1+ n))))

  (setq line-list (reverse! line-list))

  (define number-len (length (number->string (vec-ref (car (tail line-list)) 0))))

  (foreach
    (lambda (x)
      (printf "%*s %s%s"
              number-len
              (vec-ref x 0)
              (if (vec-ref x 1)
                line-prefix
                not-curline-prefix)
              (vec-ref x 2)))
    line-list))

(define (debug-list-src ctx,rest)
  (define 1st-line nil)
  (define cur nil)
  (cond
    [(and rest
       (setq 1st-line (car rest))
       (setq cur (debug-ctx-list-src ctx 1st-line)))
     (define last-line (and (cdr rest) (car (cdr rest))))
     (if last-line
       (setq last-line (1+ last-line))
       (setq last-line (+ 1st-line default-list-line-num)))
     (print-src-from-to ctx
                        cur
                        1st-line
                        last-line)]
    [(setq cur (debug-ctx-list-src ctx))
     (setq 1st-line (vec-ref cur 0))
     (define last-line (+ 1st-line default-list-line-num))
     (print-src-from-to ctx
                        cur
                        1st-line
                        last-line)
     (debug-ctx-set-list-src ctx last-line)]
    [1 (println "[EOF]")]))

(define (debug-return ctx)
  (debug-ctx-set-step-out ctx)
  (debug-continue ctx))

(define (debug-step ctx)
  (debug-ctx-set-step-into ctx)
  (debug-continue ctx))

(define (debug-next ctx)
  (debug-ctx-set-step-over ctx)
  (debug-continue ctx))

(define (debug-until ctx,rest)
  (apply debug-ctx-set-until ctx rest)
  (debug-continue ctx))

(define (debug-where ctx)
  (debug-ctx-back-trace ctx line-prefix))

(define (debug-thread ctx,rest)
  (if rest
    (if (debug-ctx-switch-thread ctx (car rest))
      (debug-ctx-print-cur-frame ctx line-prefix))
    (debug-ctx-list-thread ctx line-prefix)))

(define (debug-up ctx,rest)
  (define count (if (and rest (> (car rest) 0)) (car rest) 1))
  (define last-result nil)
  (do [(c 0 (1+ c))]
    [(or (>= c count)
       (not (if (define cur-result (debug-ctx-up ctx))
              (setq last-result cur-result))))])

  (when last-result
    (debug-ctx-print-cur-frame ctx line-prefix)))

(define (debug-down ctx,rest)
  (define count (if (and rest (> (car rest) 0)) (car rest) 1))
  (define last-result nil)
  (do [(c 0 (1+ c))]
    [(or (>= c count)
       (not (if (define cur-result (debug-ctx-down ctx))
              (setq last-result cur-result))))])

  (when last-result
    (debug-ctx-print-cur-frame ctx line-prefix)))

(define debug-cmd-func
  (make-hash
    'exit debug-ctx-exit
    'continue debug-continue
    'restart debug-restart
    'break debug-breakpoint
    'tbreak debug-temporary-breakpoint
    'delete debug-del-breakpoint
    'disable debug-dis-breakpoint
    'enable debug-enable-breakpoint
    'list debug-list-src
    'next debug-next
    'step debug-step
    'return debug-return
    'eval debug-ctx-eval
    'until debug-until
    'where debug-where
    'up debug-up
    'down debug-down
    'thread debug-thread
    'help debug-help))

(define (debug-run ctx prompt file-prefix line-prefix)
  (print-cur-line ctx file-prefix line-prefix)
  (do []
    [(debug-ctx-exit? ctx)]
    (define cmd (debug-ctx-repl ctx prompt))
    (call/eh
      (lambda ()
        (unless (eof? cmd)
          (define cmd-head (if (symbol? cmd) cmd (car cmd)))
          (define cmd-rest (if (symbol? cmd) nil (cdr cmd)))
          (define cmd-func (get-cmd-func debug-cmd-func cmd-head))
          (apply cmd-func ctx cmd-rest)))
      nil (lambda (e) (println "*** invalid command ***")))))

(define (fdb-main)

  (define arg-list (cdr (argv)))

  (if (null arg-list)
    (exit))

  (define file-name (car arg-list))

  (define dbg-ctx (make-debug-ctx file-name arg-list))

  (when (error? dbg-ctx)
    (raise dbg-ctx))

  (define prompt "(fdb) ")
  
  (define cmd-func-table
    (make-hash))

  (debug-run dbg-ctx prompt file-prefix line-prefix))

(if *main?*
  (fdb-main))
