(import (only (.. utils m) static-strcat))

(import (.. bdb))

(define file-prefix "> ")
(define line-prefix "-> ")

(define help-doc
  (static-strcat
    "help: print this help doc or print the help of command\n"
    "exit: exit\n"
    "list: list source code\n"
    "continue: continue the program until end or reach break point\n"
    "break: set break point\n"
    "delete: delete break point\n"
    "next: run the program until next line\n"
    "step: run the program until next line, but step in function\n"
    "restart: restart the debugger\n"
    "return: run the program until function return\n"))

(define help-doc-hash
  (make-hash
    'exit "exit"
    'list "list source code"
    'continue "continue the program until end or reach break point"
    'break "set break point"
    'delete "delete break point"
    'next "run the program until next line, but step in function"
    'step "run the program until next line, but step in function"
    'return "run the program until function return"
    'restart "restart the debugger"
    'help "print this help doc or print the help of command"))

(define (print-cur-line ctx file-prefix line-prefix)
  (define cur-file-line (debug-ctx-get-curline ctx))
  (println file-prefix
         (vec-ref cur-file-line 0)
         ":"
         (vec-ref cur-file-line 1))
  (print line-prefix (vec-ref cur-file-line 2)))

(define (unknown-cmd-func,_)
  (println "unknown command"))

(define (debug-continue ctx)
  (when (debug-ctx-continue ctx)
    (print-cur-line ctx file-prefix line-prefix)))

(define (print-break-point breakpoint)
  (println "breakpoint "
           (vec-ref breakpoint 0)
           " at "
           (vec-ref breakpoint 1)
           ":"
           (vec-ref breakpoint 2)))

(define (debug-breakpoint ctx,rest)
  (cond
    [rest
      (define breakpoint (apply debug-ctx-set-break ctx rest))
      (if (vector? breakpoint)
        (print-break-point breakpoint)
        (println breakpoint))]
    [1
     (define breakpoints (debug-ctx-list-break ctx))
     (when breakpoints
       (foreach print-break-point breakpoints))]))

(define (debug-del-breakpoint ctx,rest)
  (foreach
    (lambda (num)
      (define bp (debug-ctx-del-break ctx num))
      (if (vector? bp)
        (begin
          (print "deleted ")
          (print-break-point bp))
        (begin
          (if (> num bp)
            (println "breakpoint number "
                     num
                     " out of range")
            (println "breakpoint number "
                     num
                     " already be deleted")))))
    rest))

(define default-list-line-num 11)

(define (print-src-from-to ctx cur 1st last)
  (define not-curline-prefix (make-string (length line-prefix) #\\s))
  (define line-list '())
  (define number-len 0)
  (setq line-list (cons cur line-list))
  (let loop [(n (1+ 1st))]
    (define cur (debug-ctx-list-src ctx n))
    (when (and (< n last) cur)
      (setq line-list (cons cur line-list))
      (loop (1+ n))))

  (setq line-list (reverse! line-list))

  (foreach
    (lambda (x)
      (define cur-len (length (number->string (vec-ref x 0))))
      (if (> cur-len number-len)
        (setq number-len cur-len)))
    line-list)

  (foreach
    (lambda (x)
      (printf "%*s %s%s"
              number-len
              (vec-ref x 0)
              (if (vec-ref x 1)
                line-prefix
                not-curline-prefix)
              (vec-ref x 2)))
    line-list))

(define (debug-list-src ctx,rest)
  (define 1st-line nil)
  (define cur nil)
  (cond
    [(and rest
       (setq 1st-line (car rest))
       (setq cur (debug-ctx-list-src ctx 1st-line)))
     (define last-line (and (cdr rest) (car (cdr rest))))
     (if last-line
       (setq last-line (1+ last-line))
       (setq last-line (+ 1st-line default-list-line-num)))
     (print-src-from-to ctx
                        cur
                        1st-line
                        last-line)]
    [(setq cur (debug-ctx-list-src ctx))
     (setq 1st-line (vec-ref cur 0))
     (define last-line (+ 1st-line default-list-line-num))
     (print-src-from-to ctx
                        cur
                        1st-line
                        last-line)
     (debug-ctx-set-list-src ctx last-line)]
    [1 (println "[EOF]")]))

(define (debug-return ctx)
  (debug-ctx-set-step-out ctx)
  (when (debug-ctx-continue ctx)
    (print-cur-line ctx file-prefix line-prefix)))

(define (debug-step ctx)
  (debug-ctx-set-step-into ctx)
  (when (debug-ctx-continue ctx)
    (print-cur-line ctx file-prefix line-prefix)))

(define (debug-next ctx)
  (debug-ctx-set-step-over ctx)
  (when (debug-ctx-continue ctx)
    (print-cur-line ctx file-prefix line-prefix)))

(define (debug-until ctx,rest)
  (apply debug-ctx-set-until ctx rest)
  (when (debug-ctx-continue ctx)
    (print-cur-line ctx file-prefix line-prefix)))

(define (debug-where ctx)
  (debug-ctx-back-trace ctx line-prefix))

(define (debug-up ctx,rest)
  (define count (if (and rest (> (car rest) 0)) (car rest) 1))
  (define last-result nil)
  (do [(c 0 (1+ c))]
    [(or (>= c count)
       (not (if (define cur-result (debug-ctx-up ctx))
              (setq last-result cur-result))))])

  (when last-result
    (debug-ctx-print-cur-frame ctx line-prefix)))

(define (debug-down ctx,rest)
  (define count (if (and rest (> (car rest) 0)) (car rest) 1))
  (define last-result nil)
  (do [(c 0 (1+ c))]
    [(or (>= c count)
       (not (if (define cur-result (debug-ctx-down ctx))
              (setq last-result cur-result))))])

  (when last-result
    (debug-ctx-print-cur-frame ctx line-prefix)))

(define debug-cmd-func
  (make-hash
    'exit debug-ctx-exit
    'continue debug-continue
    'break debug-breakpoint
    'delete debug-del-breakpoint
    'list debug-list-src
    'next debug-next
    'step debug-step
    'return debug-return
    'eval debug-ctx-eval
    'until debug-until
    'where debug-where
    'up debug-up
    'down debug-down
    'help (lambda (_,rest)
            (if rest
              (if (cdr rest)
                (println "invalid command\n")
                (println (hash-ref help-doc-hash
                                   (car rest)
                                   "do not have such a command")
                         #\\n))
              (println help-doc)))))

(define cmd-abbr-map
  #hash((b,break)
        (c,continue)
        (n,next)
        (s,step)
        (r,return)
        (h,help)))

(define (debug-ctx-run ctx prompt file-prefix line-prefix)
  (print-cur-line ctx file-prefix line-prefix)
  (do []
    [(debug-ctx-end? ctx)]
    (define cmd (debug-ctx-repl ctx prompt))
    (unless (eof? cmd)
      (define cmd-func (hash-ref debug-cmd-func
                                 (car cmd)
                                 unknown-cmd-func))
      (apply cmd-func ctx (cdr cmd)))))

(define (fdb-main)

  (define arg-list (cdr (argv)))

  (if (null arg-list)
    (exit))

  (define file-name (car arg-list))

  (define dbg-ctx (make-debug-ctx file-name arg-list))

  (when (error? dbg-ctx)
    (raise dbg-ctx))

  (define prompt "(fdb) ")
  
  (define cmd-func-table
    (make-hash))

  (debug-ctx-run dbg-ctx prompt file-prefix line-prefix))

(if *main?*
  (fdb-main))
