(module
  utils
  [
   caar cadr cdar cddr
   caaar caadr cadar caddr
   cdaar cdadr cddar cdddr
   caaaar caaadr caadar caaddr
   cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr
   cddaar cddadr cdddar cddddr
   fprint fprin1
   square min max
   merge-sort! merge-sort
   (defmacro (let d,b)
     (begin
       (define args nil)
       (define vals nil)
       (cond [(symbol? d)
              (setq
                args
                (cond
                  [(car b)
                   (map (lambda (sd) (nth 0 sd)) (car b))]
                  [1 nil]))
              (setq
                vals
                (cond
                  [(car b)
                   (map (lambda (sd) (nth 1 sd)) (car b))]
                  [1 nil]))
              `(let ()
                 (define ~d
                   (lambda ~args
                     ~@(cdr b)))
                 (~d ~@vals))]
         [(pair? d)
          (setq args
            (map (lambda (sd) (nth 0 sd)) d))
          (setq vals
            (map (lambda (sd) (nth 1 sd)) d))
          `((lambda ~args ~@b) ~@vals)]
         [(null d)
          `((lambda () ~@b))]
         [1 (raise (error "expanding-macro-let"
                          'syntax-error
                          "Wrong type of object behind key word:let\n"))])))
   (defmacro (let* d,b)
     (cond ((or (atom d)
                (null d)
                (null (cdr d)))
            `(let ~d ~@b))
       (1
        `(let (~(car d))
           (let* ~(cdr d)
             ~@b)))))

   (defmacro (letrec d,b)
     (begin
       (define dfs
         (map (lambda (sd)
                `(define ~(car sd) ~@(cdr sd))) d))
       `(let () ~@dfs ~@b)))

   (defmacro (if condition exp1)
     `(cond (~condition ~exp1)))

   (defmacro (if condition exp1 exp2)
     `(cond (~condition ~exp1)
        (1 ~exp2)))

   (defmacro (when pred,expressions)
     `(cond [~pred
              ~@expressions]))

   (defmacro (unless pred,expressions)
     `(cond [(not ~pred)
             ~@expressions]))

   (defmacro (unless pred,expressions)
     `(cond [(not ~pred)
             ~@expressions]))

   (defmacro (case (s v),b)
     (begin
       (define body
         (let [(tb (map (lambda (x) (cdr x)) b))
               (cs (map (lambda (x)
                          (if (pair? x)
                            `(member ~s '~x)
                            x))
                        (map (lambda (x) (nth 0 x)) b)))]
           (map (lambda (x)
                  (define r (cons x (car tb)))
                  (setq tb (cdr tb))
                  r)
                cs)))
       `((lambda (~s) (cond,~body)) ~v)))

   (defmacro (define (name,args),body)
     `(define ~name
        (lambda ~args
          ~@body)))

   (defmacro (->> x,forms)
     (begin
       (define car-forms (car forms))
       (let iter [(c (cdr forms))
                  (r (if (pair? car-forms)
                       `(~@car-forms ~@`(~x))
                       `(~car-forms,(~x))))]
         (cond
           [c
             (define car-c (car c))
             (iter (cdr c)
                   (if (pair? car-c)
                     `(~@car-c ~@`(~r))
                     `(~car-c,(~r))))]
           [1 r]))))

   (defmacro (-> x,forms)
     (begin
       (define car-forms (car forms))
       (let iter [(c (cdr forms))
                  (r (if (pair? car-forms)
                       `(~(car car-forms)
                          ~@`(~x)
                          ,~(cdr car-forms))
                       `(~car-forms,(~x))))]
         (cond
           [c (define car-c (car c))
              (iter (cdr c)
                    (if (pair? car-c)
                      `(~(car car-c)
                         ~@`(~r)
                         ,~(cdr car-c))
                      `(~car-c,(~r)))
                    )]
           [1 r]))))
   ]

  (define caar (lambda (a)
                 (car (car a))))

  (define cadr (lambda (a)
                 (car (cdr a))))

  (define cdar (lambda (a)
                 (cdr (car a))))

  (define cddr (lambda (a)
                 (cdr (cdr a))))

  (define caaar (lambda (a)
                  (car (car (car a)))))

  (define caadr (lambda (a)
                  (car (car (cdr a)))))

  (define cadar (lambda (a)
                  (car (cdr (car a)))))

  (define caddr (lambda (a)
                  (car (cdr (cdr a)))))

  (define cdaar (lambda (a)
                  (cdr (car (car a)))))

  (define cdadr (lambda (a)
                  (cdr (car (cdr a)))))

  (define cddar (lambda (a)
                  (cdr (cdr (car )))))

  (define cdddr (lambda (a)
                  (cdr (cdr (cdr a)))))

  (define caaaar (lambda (a)
                   (car (car (car (car a))))))

  (define caaadr (lambda (a)
                   (car (car (car (cdr a))))))

  (define caadar (lambda (a)
                   (car (car (cdr (car a))))))

  (define caaddr (lambda (a)
                   (car (car (cdr (cdr a))))))

  (define cadaar (lambda (a)
                   (car (cdr (car (car a))))))

  (define cadadr (lambda (a)
                   (car (cdr (car (cdr a))))))

  (define caddar (lambda (a)
                   (car (cdr (cdr (car a))))))

  (define cadddr (lambda (a)
                   (car (cdr (cdr (cdr a))))))

  (define cdaaar (lambda (a)
                   (cdr (car (car (car a))))))

  (define cdaadr (lambda (a)
                   (cdr (car (car (cdr a))))))

  (define cdadar (lambda (a)
                   (cdr (car (cdr (car a))))))

  (define cdaddr (lambda (a)
                   (cdr (car (cdr (cdr a))))))

  (define cddaar (lambda (a)
                   (cdr (cdr (car (car a))))))

  (define cddadr (lambda (a)
                   (cdr (cdr (car (cdr a))))))

  (define cdddar (lambda (a)
                   (cdr (cdr (cdr (car a))))))

  (define cddddr (lambda (a)
                   (cdr (cdr (cdr (cdr a))))))

  (define fprint
    (lambda (f,l)
      (define p-iter
        (lambda (c)
          (cond (c (princ (car c) f)
                   (p-iter (cdr c))))))
      (p-iter l)))

  (define fprin1
    (lambda (f,l)
      (define w-iter
        (lambda (c)
          (cond (c (prin1 (car c) f)
                   (w-iter (cdr c))))))
      (w-iter l)))

  (define square
    (lambda (x)
      (* x x)))

  (define min
    (lambda (a b)
      (cond
        [(< a b) a]
        [1 b])))

  (define max
    (lambda (a b)
      (cond
        [(> a b) a]
        [1 b])))

  (define merge-sort!
    (lambda (cmpf ls)
      (define partition
        (lambda (ls)
          (define fast-and-slow
            (lambda (h s f)
              (define nf (and f (cdr f)))
              (cond
                [nf (fast-and-slow (cdr h) (cdr s) (cdr nf))]
                [1
                 (set-cdr! h nil)
                 s])))
          (fast-and-slow (cons nil ls) ls ls)))

      (define merge
        (lambda (l h)
          (define head '((),()))
          (define m-iter
            (lambda (c l h)
              (cond
                [(and l h)
                 (define cl (car l))
                 (define ch (car h))
                 (define r (cmpf cl ch))
                 (cond
                   [r
                     (set-cdr! c (cons cl nil))
                     (m-iter (cdr c) (cdr l) h)]
                   [1
                    (set-cdr! c (cons ch nil))
                    (m-iter (cdr c) l (cdr h))])]
                [1
                 (set-cdr! c (cond [l l][1 h]))])))
          (m-iter head l h)
          (cdr head)))
      (define msort!
        (lambda (l)
          (cond
            [(and l (cdr l))
             (define h (partition l))
             (merge (msort! l)
                    (msort! h))]
            [1 l])))
      (msort! ls)))

  (define merge-sort
    (lambda (cmpf ls)
      (merge-sort! cmpf (copy ls))))

    )
