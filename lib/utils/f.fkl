;export
;  caar cadr cdar cddr
;  caaar caadr cadar caddr
;  cdaar cdadr cddar cdddr
;  caaaar caaadr caadar caaddr
;  cadaar cadadr caddar cadddr
;  cdaaar cdaadr cdadar cdaddr
;  cddaar cddadr cdddar cddddr
;  square min max
;  merge-sort! merge-sort
;  times
;  vec-merge-sort! vec-merge-sort
;  dvec-merge-sort! dvec-merge-sort

(export
  (define (caar a) (car (car a)))

  (define (cadr a) (car (cdr a)))

  (define (cdar a) (cdr (car a)))

  (define (cddr a) (cdr (cdr a)))

  (define (caaar a) (car (car (car a))))

  (define (caadr a) (car (car (cdr a))))

  (define (cadar a) (car (cdr (car a))))

  (define (caddr a) (car (cdr (cdr a))))

  (define (cdaar a) (cdr (car (car a))))

  (define (cdadr a) (cdr (car (cdr a))))

  (define (cddar a) (cdr (cdr (car ))))

  (define (cdddr a) (cdr (cdr (cdr a))))

  (define (caaaar a) (car (car (car (car a)))))

  (define (caaadr a) (car (car (car (cdr a)))))

  (define (caadar a) (car (car (cdr (car a)))))

  (define (caaddr a) (car (car (cdr (cdr a)))))

  (define (cadaar a) (car (cdr (car (car a)))))

  (define (cadadr a) (car (cdr (car (cdr a)))))

  (define (caddar a) (car (cdr (cdr (car a)))))

  (define (cadddr a) (car (cdr (cdr (cdr a)))))

  (define (cdaaar a) (cdr (car (car (car a)))))

  (define (cdaadr a) (cdr (car (car (cdr a)))))

  (define (cdadar a) (cdr (car (cdr (car a)))))

  (define (cdaddr a) (cdr (car (cdr (cdr a)))))

  (define (cddaar a) (cdr (cdr (car (car a)))))

  (define (cddadr a) (cdr (cdr (car (cdr a)))))

  (define (cdddar a) (cdr (cdr (cdr (car a)))))

  (define (cddddr a) (cdr (cdr (cdr (cdr a)))))

  (define (square x) (* x x))

  (define (min a b) (if (< a b) a b))

  (define (max a b) (if (> a b) a b)))

(export
  (define (merge-sort! cmpf l)
    (if (and l (cdr l))
      (let [(h (do [(h (cons nil l) (cdr h))
                    (s l (cdr s))
                    (f (and l (cdr l)) (cdr f))]
                 [(not f) (begin (cdr-set! h nil) s)]))]
        (let [(l (merge-sort! cmpf l))
              (h (merge-sort! cmpf h))
              (head '((),()))]
          (do [(c head (cdr c))
               (l l)
               (h h)]
            [(not (and l h)) (cdr-set! c (if l l h))]
            (let* [(cl (car l))
                   (ch (car h))
                   (r (cmpf cl ch))]
              (cond
                [r
                  (cdr-set! c (cons cl nil))
                  (setq l (cdr l))]
                [1
                 (cdr-set! c (cons ch nil))
                 (setq h (cdr h))])))
          (cdr head)))
      l)))

(export (define (merge-sort cmpf ls) (merge-sort! cmpf (copy ls))))

(export
  (define (times f t)
    (do [(c 0 (setq c (1+ c)))]
      [(>= c t)]
      (f))))

(export
  (define (vec-merge-sort! cmpf vec)
    (throw 'incomplete-function (format "function: %s is incomplete" *func*)))
  (define (vec-merge-sort cmpf vec)
    (throw 'incomplete-function (format "function: %s is incomplete" *func*))))
