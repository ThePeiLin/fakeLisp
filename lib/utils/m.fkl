(export
  (defmacro ~(case (~s ~v),~b)
    (begin
      (define body
        (let [(tb (map (lambda (x) (cdr x)) b))
              (cs (map (lambda (x)
                         (if (pair? x)
                           `(member ~s '~x)
                           x))
                       (map (lambda (x) (nth 0 x)) b)))]
          (map (lambda (x)
                 (define r (cons x (car tb)))
                 (setq tb (cdr tb))
                 r)
               cs)))
      `(let [(~s ~v)]
         (cond,~body))))

  (defmacro ~(->> ~x,~forms)
    (let [(carc (car forms))]
      (do [(c (cdr forms) (cdr c))
           (r (if (pair? carc)
                `(~@carc ~@`(~x))
                `(~carc,(~x)))
              (if (pair? carc)
                `(~@carc ~@`(~r))
                `(~carc,(~r))))]
        [(null c) r]
        (setq carc (car c)))))

  (defmacro ~(-> ~x,~forms)
    (let [(carc (car forms))]
      (do [(c (cdr forms) (cdr c))
           (r (if (pair? carc)
                `(~(car carc)
                   ~@`(~x)
                   ,~(cdr carc))
                `(~carc,(~x))))]
        [(null c) r]
        (setq carc (car c))))))

